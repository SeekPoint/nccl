NCCL 资料
NCCL官方说明：
https://devblogs.nvidia.com/fast-multi-gpu-collectives-nccl/
https://developer.nvidia.com/nccl
http://docs.nvidia.com/deeplearning/sdk/nccl-developer-guide/index.html

https://lgd.gd/2021/03/21/NCCL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/
NCCL源码阅读笔记

https://blog.csdn.net/kidgin7439/category_11998768.html  和知乎同名的
NVIDIA NCCL 源码学习（十）- 多机间ncclSend和ncclRecv的过程
NVIDIA NCCL 源码学习（九）- 单机内ncclSend和ncclRecv的过程
NVIDIA NCCL 源码学习（八）- 数据通信链路transport的建立
https://blog.csdn.net/kidgin7439/article/details/126953432
最后简单总结下，建链的过程都是以下过程：
接收端 执行recv setup，创建buffer等，将相关信息记录到connectIndo，启动一个监听socket，ip port同样记录到connectInfo，通过bootstrap发送connectInfo到 发送端。
发送端 执行send setup，创建buffer等，将相关信息记录到connectInfo，然后发送给 接收端。这一步rdma场景没有用到connectInfo。
发送端 接受到步骤1中 接收端 的信息，然后建立 发送端 到 接收端 的链接，p2p场景的话只是简单记录对端buffer，rdma场景的话需要初始化qp到INIT状态。
接收端 接受到步骤2中send发送的信息，然后建立 接收端 到 发送端 的链接，p2p场景还是记录对端buffer，rdma场景需要初始化qp到RTS状态，将本端的qp信息发送回对端。
如果rdma场景的话，发送端 还需接收对端的qp状态初始化本端的qp到RTS状态。


NVIDIA NCCL 源码学习（七）- 机器间channel连接
https://blog.csdn.net/KIDGIN7439/article/details/128144057
NVIDIA NCCL 源码学习（六）- channel搜索
https://zhuanlan.zhihu.com/p/653440728
NVIDIA NCCL 源码学习（五）- 路径计算
https://my.oschina.net/oneflow/blog/10089670
NVIDIA NCCL 源码学习（四）- 建图过程
https://zhuanlan.zhihu.com/p/640812018
NVIDIA NCCL 源码学习（三）- 机器内拓扑分析
https://zhuanlan.zhihu.com/p/625606436
NVIDIA NCCL 源码学习（二）- bootstrap网络连接的建立
https://zhuanlan.zhihu.com/p/620499558
NVIDIA NCCL 源码学习（一）- 初始化及ncclUniqueId的产生
https://zhuanlan.zhihu.com/p/614746112


https://blog.csdn.net/weixin_34313182/article/details/92119606
nvidia-nccl 学习笔记
NCCL1 vs NCCL2
nccl1：
nccl1支持单机多卡通信，不支持多机通信。
开源地址：https://github.com/NVIDIA/nccl-tests
nccl2:
nccl2支持多机通信，在nccl1的基础上增加了多机通信策略。多机通信可进行通信协议的选择，支持通过IB、TCP等协议实现多机间数据通信。
NCCL2接口
NCCL 动态扩展
单机多卡多线程动态扩展
设计思路：
采用在线程内各自初始化自己communicator的方法进行初始化（在主线程中创建ncclid，该ncclid对全局线程可见）。当某一个线程调用merge操作失败时，查看是否因为某个线程退出引起的。
如果因为某个线程退出引起merge失败，这时每个线程重新初始化自己的communicator，并进行上一步的merge操作（该次初始化时device已经减少，相当于重新创建communicator）

测试结论：
1. 每个线程初始化自己OK
2. merge操作过程中如果出现某个线程退出，其他线程会处于block状态（不返回）
结论
单机多卡（多线程）动态扩展无法支持。
单机/多机多卡多进程动态扩展
设计思路：
采用在进程内各自初始化自己communicator的方法进行初始化（初始化时，0号进程使用tpc协议广播ncclid到全部进程）。当某一个进程调用merge操作失败时，查看是否是因为有进程退出引起的。 如果因为某个进程退出引起merge失败，这时每个进程重新初始化自己的communicator，并进行上一步的merge操作（该次初始化时device已经减少，相当于重新创建communicator）

测试结论： 1. server进程（TCP server端）创建ncclId，并且将该进程bcast到所有work进程（TCP client端），然后进行通信是可以的（server进程可以不参与通信）
2. merge操作过程中如果出现某个进程退出，其他进程全部处于block状态（不返回），且这时候其他进程的GPU使用率是100%，cpu使用100%。
结论
单机／多机多卡多进程动态扩展无法支持。


https://www.zhihu.com/question/63219175/answer/206697974
如何理解Nvidia英伟达的Multi-GPU多卡通信框架NCCL？


https://www.zhihu.com/question/63219175
如何理解Nvidia英伟达的Multi-GPU多卡通信框架NCCL？



https://lgd.gd/2021/03/21/NCCL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/
NCCL源码阅读笔记

NCCL相关笔记
https://blog.csdn.net/eternal963/article/details/130754512?ops_request_misc=&request_id=&biz_id=102&utm_term=NCCL&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-130754512.nonecase&spm=1018.2226.3001.4449

NCCL、OpenMPI、Gloo对比
https://blog.csdn.net/taoqick/article/details/126449935?ops_request_misc=&request_id=&biz_id=102&utm_term=NCCL&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-126449935.nonecase&spm=1018.2226.3001.4449